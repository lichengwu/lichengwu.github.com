---
layout: post
catalog: true
title: "《Head First 设计模式》读书笔记"
description: ""
category: design-pattern
subhead: ''
tags: [java, design-pattern]

---

#### 1.策略模式(Strategy)

定义算法，将他们分别封装起来，让他们可以相互替换，让算法变化对客户端透明。

#### 2.观察者模式(Observer)

解耦一系列对象的通知状态。定义对象之间的一对多依赖，当一端对象发生变换，通知多端。

#### 3.装饰模式(Decorator)

动态将责任附加到对象上。对扩展开放，对修改封闭。

#### 4.工厂模式(Factory)

**工厂方法：**定义一个创建对象的接口，由子类实现这个接口决定怎样创建具体类。工厂方法把对象的创建延迟到子类。

**抽象工厂：**定义一个接口，用于创建相关或依赖对象的家族，而不明确指定具体类。

#### 5.单例模式(Singleton)

确保一个类只有一个实例，并且提供一个安全的全局访问点。

如果对多线程没有要求，可以直接在静态方法中创建。

如果存在资源竞争，采用“饿汉”方式创建。

如果jdk4之后，可有采用double checked locking

#### 6.命令模式(Command)

将请求封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象。

#### 7.适配器模式(Adapter)

改变一个接口成为一个客户端希望的样子。让原本不兼容的接口能够相互合作。

#### 8.外观模式(Facade)

简化系统接口，对客户端提供一个简单接口。

#### 9.模板方法模式(Template Method)

在方法中定义一个算法的骨架，而将一些步骤延迟到子类实现。使子类在不改变算法结构的情况下，重新定义算法的某些步骤。

#### 10.迭代器模式(Iterator)

提供一种方法顺序访问集合中的每个元素，而又不暴露其内部的表示。

#### 11.组合模式(Composite)

允许你将对象组成树形结构来表现“整体/部分”的层次结构。组合能让客户端以一致的方式处理个别对象和对象组合。

#### 12.状态模式(State)

允许对象内部状态改变时，改变它的行为，对象看起来就行修改了它的类。

#### 13.代理模式(Proxy)

为对象提供一个替身或者占位符来访问这个对象。

#### 14.复合模式
结合多个模式，组成一个解决方案。
MVC中：

    M：观察者模式
    V：组合模式
    C：策略模式


